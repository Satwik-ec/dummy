#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PCIe Regression Summary -> Excel (formatted like screenshot)

Detection rules (as per your latest requirements):
- Config directory can be anything, but config dir name contains 'uio' (case-insensitive)
- Config dir must have <config>/sim/
- Under <config>/sim/:
  - compile directories begin with 'compile_dw_'
    - VDUT compile dir contains 'vdut' in dir name
    - VIP  compile dir contains 'vip'  in dir name
    - compile result: <compile_dir>/test.log
        PASS if second-last non-empty line contains: "database successfully generated"
        FAIL otherwise; extract errors by matching "Error-["
  - if BOTH VDUT and VIP compile PASS => run starts
  - test directories:
      - not starting with 'compile_dw_'
      - name contains 'vtb' (case-insensitive)
      - each has test.log
      - FAIL if log contains UVM_ERROR or UVM_FATAL (counted); else PASS

Excel output layout (matches screenshot):
CONFIG NAME | LP  | Compilation/Run status | Todays Date
-------------------------------------------------------
cfgX        |VDUT | Compilation Status : PASS/FAIL ...
           |     | Run Results : TOTAL=.. PASS=.. FAIL=.. (and optionally per-test)
           |VIP  | Compilation Status : ...
           |     | Run Results : ...

Usage:
  python3 regress_summary_excel_uio_py34.py /path/to/regression
  python3 regress_summary_excel_uio_py34.py /path/to/regression -o /path/to/out.xlsx
  python3 regress_summary_excel_uio_py34.py /path/to/regression --no-per-test
"""

import argparse
import datetime as dt
import re
from pathlib import Path

# ---------- Parsing patterns ----------
DB_OK_STR = "database successfully generated"

# IMPORTANT: '[' must be escaped, else "unterminated character set"
ERR_PATTERN = re.compile(r"Error-\[", re.IGNORECASE)

UVM_ERR_PATTERN = re.compile(r"\bUVM_ERROR\b")
UVM_FATAL_PATTERN = re.compile(r"\bUVM_FATAL\b")

# ---------- Excel ----------
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side


# --------- Simple containers (avoid dataclasses) ----------
class CompileResult(object):
    def __init__(self, lp, status, log_path, errors, chosen_dir):
        self.lp = lp                  # "VDUT" or "VIP"
        self.status = status          # "PASS" / "FAIL" / "NA"
        self.log_path = log_path      # pathlib.Path or None
        self.errors = errors or []    # list of strings
        self.chosen_dir = chosen_dir  # str or None


class TestResult(object):
    def __init__(self, test_dir, status, uvm_error_count, uvm_fatal_count, log_path):
        self.test_dir = test_dir
        self.status = status          # PASS/FAIL
        self.uvm_error_count = uvm_error_count
        self.uvm_fatal_count = uvm_fatal_count
        self.log_path = log_path      # pathlib.Path or None


# ----------------- Helpers: file/log parsing -----------------
def safe_read_lines(log_path, max_bytes=10 * 1000 * 1000):
    """Read log file safely with max size cap."""
    try:
        with log_path.open("rb") as f:
            data = f.read(max_bytes + 1)
        if len(data) > max_bytes:
            data = data[:max_bytes]
        return data.decode(errors="replace").splitlines()
    except (IOError, OSError):
        return []


def second_last_nonempty_line_contains(lines, needle):
    """Return True if the second-last non-empty line contains needle."""
    trimmed = [l for l in lines if l.strip()]
    if not trimmed:
        return False
    if len(trimmed) < 2:
        return (needle in trimmed[-1])
    return (needle in trimmed[-2])


def extract_compile_errors(lines, max_lines=30):
    """Extract unique error lines matching Error-[ pattern."""
    errs = [l.strip() for l in lines if ERR_PATTERN.search(l)]
    seen = set()
    uniq = []
    for e in errs:
        if e not in seen:
            uniq.append(e)
            seen.add(e)
        if len(uniq) >= max_lines:
            break
    return uniq


def count_uvm(lines):
    """Count UVM_ERROR and UVM_FATAL occurrences."""
    err_cnt = sum(1 for l in lines if UVM_ERR_PATTERN.search(l))
    fatal_cnt = sum(1 for l in lines if UVM_FATAL_PATTERN.search(l))
    return err_cnt, fatal_cnt


# ----------------- Discover regression structure -----------------
def discover_configs(reg_root):
    """
    Config dirs:
      - immediate subdirs under regression root
      - name contains 'uio'
      - has sim/ directory
    """
    if not reg_root.is_dir():
        return []
    configs = []
    for p in reg_root.iterdir():
        try:
            if p.is_dir() and ("uio" in p.name.lower()) and (p / "sim").is_dir():
                configs.append(p)
        except OSError:
            # in case of permission or transient FS error
            continue
    return sorted(configs, key=lambda x: x.name)


def find_compile_dirs(sim_dir):
    """Compile directories always start with compile_dw_."""
    if not sim_dir.is_dir():
        return []
    out = []
    for p in sim_dir.iterdir():
        if p.is_dir() and p.name.startswith("compile_dw_"):
            out.append(p)
    return out


def classify_lp_from_dirname(name):
    n = name.lower()
    if "vdut" in n:
        return "VDUT"
    if "vip" in n:
        return "VIP"
    return None


def pick_newest(paths):
    return max(paths, key=lambda p: p.stat().st_mtime) if paths else None


def compile_status_for_lp(sim_dir, lp):
    """
    For a given LP (VDUT/VIP), pick newest compile_dw_* dir that matches LP substring,
    and decide PASS/FAIL by test.log.
    """
    compile_dirs = find_compile_dirs(sim_dir)
    candidates = [d for d in compile_dirs if classify_lp_from_dirname(d.name) == lp]

    chosen = pick_newest(candidates)
    if chosen is None:
        return CompileResult(lp=lp, status="NA", log_path=None, errors=[], chosen_dir=None)

    log_path = chosen / "test.log"
    lines = safe_read_lines(log_path)

    if second_last_nonempty_line_contains(lines, DB_OK_STR):
        return CompileResult(lp=lp, status="PASS",
                             log_path=(log_path if log_path.exists() else None),
                             errors=[], chosen_dir=chosen.name)

    errs = extract_compile_errors(lines)
    return CompileResult(lp=lp, status="FAIL",
                         log_path=(log_path if log_path.exists() else None),
                         errors=errs, chosen_dir=chosen.name)


def find_test_dirs(sim_dir):
    """
    Test directories:
      - under sim/
      - not starting with compile_dw_
      - contains 'vtb' in name (based on your environment)
    """
    if not sim_dir.is_dir():
        return []
    out = []
    for p in sim_dir.iterdir():
        if not p.is_dir():
            continue
        if p.name.startswith("compile_dw_"):
            continue
        if "vtb" not in p.name.lower():
            continue
        out.append(p)
    return sorted(out, key=lambda x: x.name)


def parse_test_results(sim_dir):
